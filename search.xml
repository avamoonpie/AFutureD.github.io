<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SYNU-2015-training-题解]]></title>
    <url>%2F2017%2F02%2F12%2FSYNU-2015-training-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题解 A - Til the Cows Come Home描述Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible. Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it. Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists. Input Line 1: Two integers: T and N Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100. Output Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1. Sample Input 5 51 2 202 3 303 4 204 5 201 5 100 Sample Output 90 简述题意与思路这题是一个很裸的最短路源点为n,终点为 1。套一下dijkstra的模版就好了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768include &lt;iostream&gt;include &lt;cstring&gt;include &lt;vector&gt;include &lt;queue&gt;include &lt;stdio.h&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Edge &#123; int vertex, weight;&#125;;class Graph &#123;private: int n; vector&lt;Edge&gt; * edges; bool * visited;public: int * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new int[n]; visited = new bool[n]; memset(visited, 0, n * sizeof(bool)); memset(dist, 0x3f, n * sizeof(int)); &#125; ~Graph() &#123; delete[] dist; delete[] edges; delete[] visited; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; void dijkstra(int v) &#123; dist[v] = 0; for(int i = 0;i &lt; n;i++)&#123; int min_dist = INF,min_vertex; for(int j = 0;j &lt; n; j++)&#123; if(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; visited[min_vertex] = 1; for(int j = 0; j &lt; edges[min_vertex].size() ;j++ )&#123; Edge tmp = edges[min_vertex][j]; if( min_dist + tmp.weight &lt; dist[tmp.vertex])&#123; dist[tmp.vertex] = min_dist + tmp.weight; &#125; &#125; &#125; &#125;&#125;;int main() &#123; int t, n; scanf("%d%d",&amp;t,&amp;n); Graph g(n); for (int i = 0; i &lt; t; i++) &#123; int a, b, c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); g.insert(a - 1, b - 1, c); &#125; g.dijkstra(n-1); cout &lt;&lt; g.dist[0] &lt;&lt; endl;&#125; B - Heavy Transportation描述BackgroundHugo Heavy is happy. After the breakdown of the Cargolifter project he can now expand business. But he needs a clever man who tells him whether there really is a way from the place his customer has build his giant steel crane to the place where it is needed on which all streets can carry the weight.Fortunately he already has a plan of the city with all streets and bridges and all the allowed weights.Unfortunately he has no idea how to find the the maximum weight capacity in order to tell his customer how heavy the crane may become. But you surely know. ProblemYou are given the plan of the city, described by the streets (with weight limits) between the crossings, which are numbered from 1 to n. Your task is to find the maximum weight that can be transported from crossing 1 (Hugo’s place) to crossing n (the customer’s place). You may assume that there is at least one path. All streets can be travelled in both directions. InputThe first line contains the number of scenarios (city plans). For each city the number n of street crossings (1 &lt;= n &lt;= 1000) and number m of streets are given on the first line. The following m lines contain triples of integers specifying start and end crossing of the street and the maximum allowed weight, which is positive and not larger than 1000000. There will be at most one street between each pair of crossings. OutputThe output for every scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line containing the maximum allowed weight that Hugo can transport to the customer. Terminate the output for the scenario with a blank line. Sample Input 13 31 2 31 3 42 3 5 Sample Output Scenario #1:4 简述题意与思路题意： n个点m条边，边的权值为最大承载量。要求输出从1点到n点能运送货物的最大重量。思路： 这题可以用prime和dijkstra两种方法，即最大生成树和最短路。prime很裸，,disjkstra需要稍加变形，由于在训练dijkstra，我就选择这个了。对于dijkstra，其松弛操作由原来的修改为最短路径改为修改为较大权值。且选点操作，改为选取边权较大的点了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980include &lt;iostream&gt;include &lt;cstring&gt;include &lt;vector&gt;include &lt;queue&gt;include &lt;stdio.h&gt;using namespace std;const int INF = -1;struct Edge &#123; long long vertex, weight;&#125;;class Graph &#123;private: int n; vector&lt;Edge&gt; * edges; bool * visited;public: long long * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new long long[n]; visited = new bool[n]; memset(visited, 0, n * sizeof(bool)); memset(dist, 0, n * sizeof(long long)); &#125; ~Graph() &#123; delete[] dist; delete[] edges; delete[] visited; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; void dijkstra(int v) &#123; dist[v] = 0; for(int i=0;i&lt;edges[0].size(); i++)&#123; dist[edges[0][i].vertex] = edges[0][i].weight; &#125; visited[0]=1; for(int i = 0;i &lt; n;i++)&#123; long long min_dist = INF,min_vertex; for(int j = 0;j &lt; n; j++)&#123; if(!visited[j] &amp;&amp; dist[j] &gt; min_dist)&#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; visited[min_vertex] = 1; for(int j = 0; j &lt; edges[min_vertex].size() ;j++ )&#123; Edge tmp = edges[min_vertex][j]; if( min(min_dist , tmp.weight) &gt; dist[tmp.vertex])&#123; dist[tmp.vertex] = min(min_dist , tmp.weight); &#125; &#125; &#125; &#125;&#125;;int main() &#123; int T; scanf("%d",&amp;T); for(int t = 1; t &lt;= T; t++)&#123; int n, m; scanf("%d%d",&amp;n, &amp;m); Graph g(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); g.insert(a - 1, b - 1, c); &#125; g.dijkstra(0); printf("Scenario #%d:\n%lld\n\n",t,g.dist[n-1]); &#125;&#125; C - Wireless Network描述An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. InputThe first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: “O p” (1 &lt;= p &lt;= N), which means repairing computer p. “S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate. The input will not exceed 300000 lines. OutputFor each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not. Sample Input 4 10 10 20 30 4O 1O 2O 4S 1 4O 3S 1 4 Sample Output FAILSUCCESS 简述题意与思路题意： 给出电脑数量n和距离d，给出n个电脑的坐标。给出操作 O 和 P，O操作表示修复电脑，P操作表示测试两台电脑是否可以通讯，对于P操作输出结果FAIL或者SUCCESS。思路： 简单的并查集题，对每个O进行Union操作；对于P进行查询集合操作，如果集合相同择SUCCESS，否则FAIL。其中Union进行的条件是，俩电脑距离是否小于d。 代码由于为AC，稍后贴出。注意题意与思路可能会改变。 D - The Suspects描述Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects. InputThe input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. OutputFor each case, output the number of suspects in one line. Sample Input 100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output 411 简述题意与思路题意： 很简单给出人数n和组数m。有m组人群，其中序号为0的那个人为疑似感染患者，输出疑似感染人群的人数。对于那m组人群需要进行合并。思路： 首先当m为0时，直接输出1，应为只有0号一个人。其他情况，对于m组进行并查集的Union算法，把属于同一组的人标为同一个组。然后输出号0所在那个组的人数就好了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455include &lt;iostream&gt;include &lt;cstring&gt;include &lt;vector&gt;include &lt;queue&gt;include &lt;stdio.h&gt;using namespace std;int const MAX = 30000 +10;int mem[MAX];int son[MAX],pre[MAX];void init()&#123; for (int i = 0; i &lt; MAX; ++i) &#123; pre[i] = i; son[i] = 1; &#125;&#125;int Find_Set(int x)&#123; return x == pre[x] ? x : Find_Set(pre[x]);;&#125;void Union(int x, int y)&#123; int root1= Find_Set(x), root2= Find_Set(y);; if(root1 != root2)&#123; pre[root2] = root1; son[root1] += son[root2]; &#125;&#125;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m) &amp;&amp; (n || m))&#123; init(); if(m == 0)&#123; cout &lt;&lt; 1 &lt;&lt;endl; continue; &#125; for(int i = 0; i &lt; m;i++) &#123; int c,one; scanf("%d%d",&amp;c,&amp;one); for(int j= 1;j &lt; c;j++)&#123; int two; scanf("%d",&amp;two); Union(one,two); &#125; &#125; printf("%d\n",son[Find_Set(0)]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod Nim游戏]]></title>
    <url>%2F2016%2F12%2F28%2FNim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[类型：Nim游戏 描述：有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。 题解：定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。 更严谨的定义是: 1.无法进行任何移动的局面（也就是terminal position）是P-position； 2.可以移动到P-position的局面是N-position； 3.所有移动都导致N-position的局面是P-position。 按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-position或者是N-position，而且可以通过定义计算出来。 结论：对于一个Nim游戏的局面(a1,a2,…,an)，它是P-position当且仅当a1 ^ a2 ^ … ^ an=0，其中^表示异或(xor)运算。 简单证明 根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题： 这个判断将所有terminal position判为P-position； 根据这个判断被判为N-position的局面一定可以移动到某个P-position； 根据这个判断被判为P-position的局面无法移动到某个P-position。 第一个命题，显然terminal position只有一个，就是全0，异或仍然是0。 第二个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an != 0，一定存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。不妨设a1 ^ a2 ^ … ^ an = k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai ^ k &lt; ai一定成立。则我们可以将ai改变成ai’ = ai ^ k，此时a1 ^ a2 ^ … ^ ai’ ^ … ^ an = a1 ^ a2 ^ … ^ an ^ k=0。 第三个命题，对于某个局面(a1,a2,…,an)，若a1 ^ a2 ^ … ^ an = 0，一定不存在某个合法的移动，将ai改变成ai’后满足a1 ^ a2 ^ … ^ ai’ ^ … ^ an = 0。因为异或运算满足消去率，由a1 ^ a2 ^ … ^ an = a1 ^ a2 ^ … ^ ai’ ^ … ^ an可以得到ai = ai’。所以将ai改变成ai’不是一个合法的移动。证毕。 根据这个定理，我们可以在O(n)的时间内判断一个Nim的局面的性质，且如果它是N-position，也可以在O(n)的时间内找到所有的必胜策略。Nim问题就这样基本上完美的解决了。 附加：当题目条件增加‘最多取k个’时，对每一堆石子mod(k+1)。 代码：1234567891011include &lt;stdio.h&gt;int main() &#123; int n, x, r = 0; scanf( "%d", &amp;n ); while( n-- ) &#123; scanf( "%d", &amp;x ); r ^= x; &#125; printf( "%c\n", r == 0 ? 'B' : 'A' ); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1272 小希的迷宫]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-1272%20%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[类型： 并查集 并查集简述：定义：并查集(union-find sets)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。 基本操作： Make_Set(x) 把每一个元素初始化为一个集合： 初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。 Find_Set(x) 查找一个元素所在的集合: 查找一个元素所在的集合，其精髓是找到这个元素所在集合的祖先！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。 Union(x,y) 合并x,y所在的两个集合： 合并两个集合，也是使一个集合的祖先成为另一个集合的祖先。具体过程为，利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。 Find_Set(x)时 路径压缩： 寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？ 答案是肯定的，这就是路径压缩，即当我们经过”递推”找到祖先节点后，“回溯”的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了。 Union(x,y)时 按秩合并： 即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。 例题：Problem Description上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 Input输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。 Output对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。 Sample Input6 8 5 3 5 2 6 45 6 0 0 8 1 7 3 6 2 8 9 7 57 4 7 8 7 6 0 0 3 8 6 8 6 45 3 5 6 5 2 0 0 -1 -1 Sample OutputYesYesNo 题解：此题是并查集的基本应用。只需要使用并查集判断是否有环路 且 是否只有单个集合。 有坑。。。 输入 0 0 输出Yes 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798include &lt;iostream&gt;include &lt;cstdio&gt;include &lt;cstring&gt;using namespace std;const int MAX = 100005;int flag = 0,maxx=0;int vis[MAX],pre[MAX]; // pre用来存index的父节点，路径压缩后存的是根节点。 //vis用来判断是否用到这个点。void init()&#123; //初始化 for (int i = 0; i &lt; MAX; ++i) &#123; pre[i] = i; &#125; memset(vis,0,sizeof(vis)); flag = 0; maxx=0;&#125;int find(int v)&#123; // find操作 int r = v; while(pre[r] != r)&#123; // 寻到当前状态的根节点 r = pre[r]; &#125; int i = v,j; while(i != r)&#123; // 回溯过程 将所有子节点的pre改为父节点。 j = pre[i]; pre[i] = r; i = j; &#125; return r;&#125;void join(int v1,int v2)&#123; int newX = find(v1),newY = find(v2); if(newX == newY &amp;&amp; v1 != v2) // 使用并查集判断时候有环路。 &#123; flag = 1; &#125; else &#123; pre[newX] = newY; // 吧点加入集合 &#125;&#125;void isconnect()&#123; // 判断是否有只有单个图。 int val = find(pre[maxx]); for (int i = 0; i &lt; maxx; ++i) &#123; if(vis[i] != 0)&#123; if(find(pre[i]) != find(pre[maxx]))&#123; flag = 1; break; &#125; &#125; &#125;&#125;int main()&#123; int x,y; while(scanf("%d%d",&amp;x,&amp;y)) &#123; init(); if(x==0&amp;&amp;y==0)&#123; printf("Yes\n"); continue; &#125; if(x == -1 &amp;&amp; y == -1) break; vis[x] = 1; vis[y] = 1; maxx = max(maxx,max(x,y)); join(x,y); while(scanf("%d%d",&amp;x,&amp;y) &amp;&amp; x &amp;&amp; y)&#123; vis[x] = 1; vis[y] = 1; maxx = max(maxx,max(x,y)); join(x,y); &#125; isconnect(); if(flag) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1851 A Simple Game]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-1851%20A%20Simple%20Game%2F</url>
    <content type="text"><![CDATA[类型： 博弈，SG函数 描述：Agrael likes play a simple game with his friend Animal during the classes. In this Game there are n piles of stones numbered from 1 to n, the 1st pile has M1 stones, the 2nd pile has M2 stones, … and the n-th pile contain Mn stones. Agrael and Animal take turns to move and in each move each of the players can take at most L1 stones from the 1st pile or take at most L2 stones from the 2nd pile or … or take Ln stones from the n-th pile. The player who takes the last stone wins. After Agrael and Animal have played the game for months, the teacher finally got angry and decided to punish them. But when he knows the rule of the game, he is so interested in this game that he asks Agrael to play the game with him and if Agrael wins, he won’t be punished, can Agrael win the game if the teacher and Agrael both take the best move in their turn? The teacher always moves first(-_-), and in each turn a player must takes at least 1 stones and they can’t take stones from more than one piles. INPUT：The first line contains the number of test cases. Each test cases begin with the number n (n ≤ 10), represent there are n piles. Then there are n lines follows, the i-th line contains two numbers Mi and Li (20 ≥ Mi &gt; 0, 20 ≥ Li &gt; 0). OUTPUT：Your program output one line per case, if Agrael can win the game print “Yes”, else print “No”. Sample input：215 421 12 2 sample output：YesNo 题解：此题有两种办法一种是nim+bash，还有一种是通过SG函数来解决]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2066 一个人的旅行]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-2066%20%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[类型： 最短路，多集合到多集合 Problem Description虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。 Input输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个； 接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路) 接着的第T+1行有S个数，表示和草儿家相连的城市； 接着的第T+2行有D个数，表示草儿想去地方。 Output输出草儿能去某个喜欢的城市的最短时间。 Sample Input6 2 31 3 51 4 72 8 123 8 44 9 129 10 21 28 9 10 Sample Output9 题解：对于集合到集合的最短路题，一种简单的做法是构建两个虚拟点，一个是虚拟起点，一个是虚拟终点，虚拟起点到起点集合的各个点的距离为0，虚拟终点到终点集合的各个点的距离为0。然后对虚拟起点和终点求一边最短路即可求得答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586include &lt;iostream&gt;include &lt;cstring&gt;include &lt;vector&gt;include &lt;queue&gt;include &lt;cstdio&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Edge &#123; int vertex, weight;&#125;;class Graph &#123;private: int n; vector&lt;Edge&gt; * edges; bool * visited;public: int * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new int[n]; visited = new bool[n]; memset(visited, 0, n); memset(dist, 0x3f, n * sizeof(int)); &#125; ~Graph() &#123; delete[] dist; delete[] edges; delete[] visited; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; void dijkstra(int v) &#123; dist[v] = 0; for(int i = 0;i &lt; n;i++)&#123; int min_dist = INF,min_vertex; for(int j = 0;j &lt; n; j++)&#123; if(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; visited[min_vertex] = 1; for(Edge &amp;j: edges[min_vertex])&#123; if( min_dist + j.weight &lt; dist[j.vertex])&#123; dist[j.vertex] = min_dist + j.weight; &#125; &#125; &#125; &#125;&#125;;int main() &#123; int T,S,D,maxn; while(scanf("%d%d%d",&amp;T,&amp;S,&amp;D)!=EOF)&#123; Graph g(1010); maxn = 0; for (int i = 0; i &lt; T; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; maxn = max(max(a,b),maxn); g.insert(a, b, c); &#125; maxn++; for (int i = 0; i &lt; S; i++) &#123; int tmp; cin &gt;&gt; tmp; g.insert(0, tmp, 0); &#125; for (int i = 0; i &lt; D; i++) &#123; int tmp; cin &gt;&gt; tmp; g.insert(maxn, tmp, 0); &#125; g.dijkstra(0); cout &lt;&lt; g.dist[maxn] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2196 Computer]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-2196%20Computer%2F</url>
    <content type="text"><![CDATA[类型： 树形DP 、树的最长路 DescriptionA school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. ​ Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. InputInput file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. OutputFor each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input51 12 13 11 1 Sample Output32344 题解：此题的意思为：树中一共n个节点，输出每个节点到其中任意一个节点的最远花费的值。 有这么一个定理： 首先假设树的最长路的两个叶子节点为v1,v2，那么现有结论，从任意一点u出发走到的最远的点一定是（v1,v2）中的一点，然后再从v1或者v2出发走到的最远点一定是v2或者v1。 因此，经过三次搜索就能找到任意一点最长路径或者说是话费。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162include &lt;iostream&gt;include &lt;cstdio&gt;include &lt;algorithm&gt;include &lt;vector&gt;include &lt;queue&gt;include &lt;cmath&gt;include &lt;cstring&gt;using namespace std;const int MAX = 10010;struct Tree&#123; int v; int dis;&#125;;vector &lt;struct Tree &gt; tree[MAX];int ans[MAX];int max_len,root;init()&#123; memset(ans,0,sizeof(ans)); memset(tree,0,sizeof(tree));&#125;void trees(int u,int v,int len)&#123; // v为当前节点，u为父节点 if(max_len &lt; len )&#123; max_len = len; root = v; &#125; for(int i = 0;i &lt; tree[v].size();i++)&#123; struct Tree new_v = tree[v][i]; if(new_v.v == u) continue; trees(v,new_v.v,len + new_v.dis); ans[new_v.v] = max (ans[new_v.v],new_v.dis + len); &#125;&#125;int main()&#123; int n; while(scanf("%d",&amp;n) != EOF)&#123; init(); int max_w = 0, w = 1; for(int i = 2;i &lt;= n; i++)&#123; int tmp,tmp_d; cin &gt;&gt; tmp &gt;&gt; tmp_d; tree[tmp].push_back(Tree&#123;i,tmp_d&#125;); tree[i].push_back(Tree&#123;tmp,tmp_d&#125;); &#125; max_len = 0; trees(-1,1,0); trees(-1,root,0); trees(-1,root,0); for(int i = 1;i &lt;= n; i++)&#123; cout &lt;&lt; ans[i] &lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2444 The Accomodation of Students]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-2444%20The%20Accomodation%20of%20Students%2F</url>
    <content type="text"><![CDATA[类型： 二分图的判断和最大匹配 Problem Description：There are a group of students. Some of them may know each other, while others don’t. For example, A and B know each other, B and C know each other. But this may not imply that A and C know each other. Now you are given all pairs of students who know each other. Your task is to divide the students into two groups so that any two students in the same group don’t know each other.If this goal can be achieved, then arrange them into double rooms. Remember, only paris appearing in the previous given set can live in the same room, which means only known students can live in the same room. Calculate the maximum number of pairs that can be arranged into these double rooms. Input：For each data set:The first line gives two integers, n and m(1&lt;n&lt;=200), indicating there are n students and m pairs of students who know each other. The next m lines give such pairs. Proceed to the end of file. Output：If these students cannot be divided into two groups, print “No”. Otherwise, print the maximum number of pairs that can be arranged in those rooms. Sample Input：4 41 21 31 42 36 51 21 31 42 53 6 Sample Output：No3 题解：这道题要先判断图是不是二分图，如果不是的话，就直接输出No,是的话就求最大匹配，建边是双向的所以要除以2。先判断能否构成二分图，判断二分图用交叉染色法从某个未染色的点出发把此点染成白色，该点周围的点染成黑色黑色周围的又染成白色，若走到某个点已经染色并且它相邻点的颜色与它一样则不是二分图，而是有奇数圈的图可以这样理解，染白色既加入X集合，黑色既加入Y集合若某个点即是X集合又是Y集合，那说明不是二分图。 其次用匈牙利算法计算最大匹配，是通过DFS搜增广路来计算最大匹配。通过搜增广路扩展匹配路径。具体为： 定义一个空集U，放入起始点。 搜索相邻的点，判断该点是否是一条匹配线的一点，不是则把那一邻点加入集合U；是，则对此点DFS搜索一个相邻的点，直到该点不在一条匹配线上。由此得到一条线段，匹配线与非匹配相交替，非匹配比匹配线多1，反过来看（把匹配看成非匹配的、非匹配看成匹配的），则是匹配比非匹配多一条。 循环步骤2，如果不能继续则结束。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566include"stdio.h"include"string.h"include"iostream"include"queue"using namespace std;define N 205int mark[N],link[N],map[N][N],color[N],n;int find(int a) //匈牙利算法&#123; int i; for(i=1;i&lt;=n;i++)&#123; if(!mark[i]&amp;&amp;map[a][i])&#123; mark[i]=1; if(!link[i]||find(link[i]))&#123; //若i已经配对，则查找和i配对的那个元素是否还能和其他元素配对 link[i]=a; //若可以则把i配给a return 1; &#125; &#125; &#125; return 0;&#125;int judge() //判断是否是二分图&#123; int i,cur; queueq; //队列声明 q.push(1); //把1加入队列 while(!q.empty())&#123; cur=q.front(); //取队首元素 q.pop(); //删除队首元素 for(i=1;i&lt;=n;i++)&#123; if(map[cur][i])&#123; //1和2、3认识则把2、3均标记为2； if(color[i]==-1)&#123; color[i]=1-color[cur]; q.push(i); &#125; else if(color[i]==color[cur]) //接下来到2出对时，color[3]=color return 0; &#125; &#125; &#125; return 1;&#125;int main()&#123; int i,j,m,ans; while(scanf("%d%d",&amp;n,&amp;m)!=-1)&#123; memset(link,0,sizeof(link)); memset(map,0,sizeof(map)); memset(color,-1,sizeof(color)); while(m--)&#123; scanf("%d%d",&amp;i,&amp;j); map[i][j]=map[j][i]=1; &#125; if(judge()==0)&#123; printf("No\n"); continue; &#125; ans=0; for(i=1;i&lt;=n;i++)&#123; memset(mark,0,sizeof(mark)); ans+=find(i); &#125; printf("%d\n",ans/2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2544 最短路]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-2544%20%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[类型： dijkstra Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0 Sample Output3 2 题解：此题解包括dijkstra的讲解。 dijistra的简述：将源点(初始点)放入一个空集合U，初始化距离(指图中的任意一点距离源点最短的距离)为0，由源点开始广度遍历，寻找到离源点最近的相邻点后加入U中，从这个点V继续广度遍历，对于每个相邻的点P，对比已知距离和由当前点V加V、P两点间边的权值，取最小后更新，在这些相邻的点中取离源点最近的点，加入集合U中，重复操作，直到U的大小等于图的点的集合。 题目简述： 简单的最短路。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071include &lt;iostream&gt;include &lt;cstring&gt;include &lt;vector&gt;include &lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Edge &#123; int vertex, weight;&#125;;class Graph &#123;private: int n; vector&lt;Edge&gt; * edges; bool * visited;public: int * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new int[n]; visited = new bool[n]; memset(visited, 0, n); memset(dist, 0x3f, n * sizeof(int)); &#125; ~Graph() &#123; delete[] dist; delete[] edges; delete[] visited; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; void dijkstra(int v) &#123; dist[v] = 0; for(int i = 0;i &lt; n;i++)&#123; int min_dist = INF,min_vertex; for(int j = 0;j &lt; n; j++)&#123; if(!visited[j] &amp;&amp; dist[j] &lt; min_dist)&#123; min_dist = dist[j]; min_vertex = j; &#125; &#125; visited[min_vertex] = 1; for(Edge &amp;j: edges[min_vertex])&#123; if( min_dist + j.weight &lt; dist[j.vertex])&#123; dist[j.vertex] = min_dist + j.weight; &#125; &#125; &#125; &#125;&#125;;int main() &#123; int n, m; while ((cin &gt;&gt; n &gt;&gt; m) &amp;&amp; n &amp;&amp; m)&#123; Graph g(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g.insert(a-1, b-1, c); &#125; g.dijkstra(0); cout &lt;&lt; g.dist[n-1] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu-2686 Matrix]]></title>
    <url>%2F2016%2F12%2F28%2FHdu-2686%20Matrix%2F</url>
    <content type="text"><![CDATA[类型：多线程DP 描述：Yifenfei very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.Every time yifenfei should to do is that choose a detour which frome the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix yifenfei choose. But from the top to the bottom can only choose right and down, from the bottom to the top can only choose left and up. And yifenfei can not pass the same area of the Matrix except the start and end. InputThe input contains multiple test cases.Each case first line given the integer n (2&lt;n&lt;30)Than n lines,each line include n positive integers.(&lt;100) outputFor each test case output the maximal values yifenfei can get. sample Input210 35 10310 3 32 5 36 7 1051 2 3 4 52 3 4 5 63 4 5 6 74 5 6 7 85 6 7 8 9 Samput Output284680 题解：这个题目是一道 多线程DP ，题目简单的可理解为，在矩阵中选择两条不相交的最优路径，最优理解为使路径上数字的和最大。简单分析之后，可以发现此题由原来方向为==左上 -&gt; 右下 -&gt; 左上== 的路径可转换为两条方向为==左上 -&gt; 右下== 的路径同时出发，且不相交，多线程 得到体现。 规定dp[x~1~][y~1~][x~2~][y~2~]表示为两条路径的终点分别为（x~1~ ，y~1~）,（x~2~ ,y~2~），原矩阵数据存在MAP[][]中。对于当前时刻的状态，因为一个点的位置的前一个状态有两种可能性，所以一共有四种可能性，状态转移方程具体为： dp[x~1~][y~1~][x~2~][y~2~] = max(dp[x~1~-1][y~1~][x~2~-1][y~2~],dp[x~1~-1][y~1~][x~2~][y~2~-1],dp[x~1~][y~1~-1][x~2~-1][y~2~],dp[x~1~][y~1~-1][x~2~][y~2~-1]) + MAP[x~1~][y~1~] 当x~1~ != x~2~ 或 y~1~ != y~2~ 时dp[x~1~][y~1~][x~2~][y~2~] += MAP[x~2~][y~2~] 分析下时间复杂度为O(n^4^)，空间复杂度为O(n^4^)。如何优化呢？ 有这么一个事实，当明确一个终点的距离原点的距离后，如果知道该终点的横左边，那么由距离可知唯一的纵左边，并且两个不同的重点有唯一相同属性到原点的距离 ，即x~1~ + y~1~ = x~2~ + y~2~。 那么我们可以设一个变量L，用来存坐标与原点的距离。dp[l][x~1~][x~2~] 则可以简单的表示出原来的dp[x~1~][y~1~][x~2~][y~2~] ，但是空间与时间复杂度变为O(n^3^). 代码：123456789101112131415161718192021222324252627282930313233343536373839include &lt;iostream&gt;include &lt;cstdio&gt;include &lt;cstring&gt;using namespace std;int max(int a,int b,int c,int d)&#123; int tmp1 = max(a,b); int tmp2 = max(c,d); return max(tmp1,tmp2);&#125;int main()&#123; int n; int MAP[40][40],dp[80][40][40]; while (scanf("%d",&amp;n) != EOF )&#123; memset(MAP,0,sizeof(MAP)); memset(dp,0,sizeof(dp)); for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= n; ++j)&#123; scanf("%d",&amp;MAP[i][j]); &#125; &#125; for (int l = 1; l &lt;= (2 * n - 1); ++l) for (int x1 = 1; x1 &lt;= n; ++x1) for (int x2 = 1; x2 &lt;=n; ++x2)&#123; int tmp_y1 = l - x1 + 1,tmp_y2 = l - x2 + 1; dp[l][x1][x2] = max(dp[l-1][x1-1][x2-1],dp[l-1][x1][x2], dp[l-1][x1-1][x2],dp[l-1][x1][x2-1]) + MAP[x1][tmp_y1]; if (x1 != x2 || tmp_y1 != tmp_y2) dp[l][x1][x2] += MAP[x2][tmp_y2]; &#125; cout &lt;&lt; dp[2*n-1][n][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Muti-treaded DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1043 Eight]]></title>
    <url>%2F2016%2F12%2F28%2FHDU-1043%20Eight%2F</url>
    <content type="text"><![CDATA[类型： A\算法* EXAMPLEdescriptionThe 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: 1 2 3 45 6 7 89 10 11 1213 14 15 x where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle: 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 1213 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively. Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, andfrustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course). In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by threearrangement. InputYou will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle 1 2 3x 4 67 5 8 is described by this list: 1 2 3 x 4 6 7 5 8 OutputYou will print to standard output either the word ``unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases. Sample Input2 3 4 1 5 x 7 6 8 Sample Outputullddrurdllurdruldr 题解这题核心思想是使用A*算法，并且需要通过hash确定每种状态的序号，以用来访问数组来确定时候被访问过和父节点的存储。 首先hash的核心算法是康托展开。其次A*算法使用估值函数确定最优节点，以放入队列中进行搜索。A*算法的参数有三个f、h、g，f = h + g，g为已花费的代价（题中指已经走过的步数），h为估算的代价（题中指在无障碍的情况下最少还需要多少步到达终点目标），正式地，这个距离叫做曼哈顿距离。 最后一点，每次数字的移动会使状态的逆序数改变，但是不改变奇偶性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179include&lt;iostream&gt;include&lt;cstdio&gt;include&lt;cstring&gt;include&lt;queue&gt;include&lt;cmath&gt;using namespace std;struct node //状态&#123; int a[10]; int f, h, g; int x; //x在的位置 friend bool operator &lt; (node a, node b) &#123; return a.f &gt; b.f; &#125;&#125;;priority_queue&lt;node&gt;que;int fac[10];//46233struct&#123; int father; char dir;&#125;vis[362881];int get_h(int a[])&#123; int h = 0; for(int i = 0; i &lt; 8; i++) &#123; if(a[i]) h += fabs((a[i]-1)/3 - i/3) + fabs((a[i]-1)%3 - i%3); &#125; return h;&#125;int Hash(int a[])&#123; int ans = 0; for(int i = 0; i &lt; 9; i++) &#123; int tmp = 0; for(int j = i+1; j &lt; 9; j++) &#123; if(a[i] &gt; a[j]) tmp++; &#125; ans += tmp*fac[8-i]; &#125; return ans+1;&#125;void prin(int n)&#123;// printf("n=%d\n", n); if(vis[n].father!=-1) &#123; prin(vis[n].father); printf("%c", vis[n].dir); &#125;&#125;void SWAP(int &amp;x, int &amp;y)&#123; int t = x; x = y; y = t;&#125;int dir[4][2] = &#123; &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;;char dd[] = "dulr";bool is(int a[])&#123; int ans = 0; for(int i = 0; i &lt; 9; i++) &#123; if(a[i]) for(int j = i+1; j &lt; 9; j++) &#123; if(a[i] &gt; a[j] &amp;&amp; a[j]) ans++; &#125; &#125; return !(ans &amp; 1);&#125;void debug(int a[])&#123; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; printf("%d ", a[i*3+j]); &#125; printf("\n"); &#125; printf("\n");&#125;int bfs(node star)&#123; while(!que.empty()) que.pop(); que.push( star ); star.h = get_h( star.a ); star.g = 0; star.f = star.g + star.h; vis[ Hash( star.a ) ].father = -1; while(!que.empty())&#123; node tmp = que.top(); que.pop(); int father = Hash(tmp.a); for(int i = 0; i &lt; 4; i++)&#123; int x = dir[i][0] + tmp.x/3; int y = dir[i][1] + tmp.x%3; if(0 &lt;= x &amp;&amp; x &lt; 3 &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; 3)&#123; node s = tmp; s.x = x*3+y; SWAP( s.a[ tmp.x ], s.a[ s.x ] ); s.g++; s.h = get_h( s.a ); s.f = s.h + s.g; int son = Hash(s.a); if(son == 46234)&#123; vis[ son ].father = father; vis[ son ].dir = dd[i]; prin(46234);printf("\n"); return 0; &#125; if(!vis[ son ].father &amp;&amp; is(s.a))&#123; vis[ son ].father = father; vis[ son ].dir = dd[i]; que.push( s ); &#125; &#125; &#125; &#125; return 1;&#125;int main(void)&#123; int i; fac[1] = 1; for(i = 2; i &lt; 10; i++) fac[i] = fac[i-1]*i; node star; char in[2];// freopen("ou.txt", "w", stdout); while(~scanf("%s", in)) &#123; memset(vis, 0, sizeof(vis)); if(in[0] == 'x') &#123; star.a[0] = 0; star.x = 0; &#125; else star.a[0] = in[0] - '0'; for(i = 1; i &lt; 9; i++) &#123; scanf("%s", in); if(in[0] == 'x') &#123; star.a[i] = 0; star.x = i; &#125; else star.a[i] = in[0] - '0'; &#125; if(!is(star.a)) &#123; printf("unsolvable\n");continue; &#125; if(Hash(star.a) == 46234) &#123;printf("\n"); continue;&#125; if(bfs(star)) &#123; printf("unsolvable\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod bash v2]]></title>
    <url>%2F2016%2F12%2F28%2F51nod%20bash%20v2%2F</url>
    <content type="text"><![CDATA[描述：有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。 Input第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9) Output共T行，如果A获胜输出A，如果B获胜输出B。 Input示例3234 Output示例BAA 题解：从1个石子推下去发现7个一循环 代码123456789101112131415161718include&lt;stdio.h&gt;int main()&#123; freopen("a.txt","r",stdin); long long N,K; int t; scanf("%d",&amp;t); int bo[7]=&#123;0,1,0,1,1,1,1&#125;; while(t--)&#123; scanf("%d",&amp;N); N%=7; printf("%d ",N); if(bo[N]) printf("A\n"); else printf("B\n"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>巴什博奕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51NOD DP-最大子矩阵和]]></title>
    <url>%2F2016%2F12%2F28%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[描述一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的 值。例如：3*3的矩阵： -1 3 -1 2 -1 3-3 1 2 和最大的子矩阵是： 3 -1-1 3 1 2 Input第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9) Output输出和的最大值。如果所有数都是负数，就输出0。 Input 示例1234 3 3-1 3 -1 2 -1 3-3 1 2 Output示例7 题解]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>基本 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 威佐夫博奕（Wythoff Game）]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%A5%95%EF%BC%88Wythoff%20Game%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类型：Wythoff Game 描述：​ 有2堆石子。A，B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。 例如：​ 2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。 题解：我们用，，，，表示两堆物品的数量并称其为局势，如果甲面对(0,0)，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出，$a_0=b_0=0$ 、 $ a_k$是未在前面出现过的最小自然数,而 $b_k= a_k + k$，奇异局势有如下三条性质: 1.任何自然数都包含在一个且仅有一个奇异局势中。 由于是未在前面出现过的最小自然数，所以有，而 。所以性质1成立。 2.任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（，）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（，）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。 3.采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（），若，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果，，那么，取走个物体，即变为奇异局势；如果 ， ,则同时从两堆中拿走个物体,变为奇异局势；如果，则从第一堆中拿走多余的数量即可；如果， ，分两种情况，第一种，,从第二里面拿走 即可；第二种，,从第二堆里面拿走 即可。 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式： ，，方括号表示取整函数奇妙的是其中出现了黄金分割数,因此发现对于任意的局势(a,b)，a&lt;b, 根据上述公式，其中k明显为a与b的差值，也正是根据这个差值来确认（a，b）是否为奇异局势。具体过程为，如果则为奇异局势。 代码：12345678910111213141516include &lt;stdio.h&gt;include &lt;math.h&gt;include &lt;iostream&gt;using namespace std;int main() &#123; int t, a, b, m; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt; b) swap(a,b); m = (int)((b-a) * (1 + sqrt(5)) / 2.0); printf("%s\n", a == m ? "B" : "A"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>威佐夫博奕（Wythoff Game）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容斥原理]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[描述容斥原理的简单描述如下： 要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。简单的说，就是对所有单个集合求和后减去单数个集合相交部分，加上双数集合相交部分。 原理公式: $$ |\bigcup Ai|=\sum{1\leq i \leq m} |Ai|-\sum{1\leq i \leq j \leq m} |A_i \cap Aj|+\sum{1\leq i \leq j \leq k \leq m} |A_i \cap A_j \cap A_k|- \cdots +(-1)^{m+1} \sum |A_1 \cap A_2 \cap A_3 \cap A_4\cdots\cap A_m| $$ 例题给定$a_1,a_2,a_3,\cdots ,a_m$ ，求1到n的整数中至少能整除a中一个元素有几个？ 代码：12345678910111213141516171819202122232425262728293031323334353637383940include &lt;iostream&gt;using namespace std;int a[4] = &#123;2,3,5,7&#125;;int n = 100,m = 4;typedef long long ll;ll gcd(ll a,ll b)&#123; ll t; if (!a || !b)return 0; if (a &lt; b)&#123;t = b; b = a; a = t;&#125; while (b != 0 )&#123; t = a % b; a = b; b = t;&#125; return a;&#125;void solve()&#123; ll res = 0; for (int i = 1; i &lt; (1 &lt;&lt; m); i++)&#123; int num = 0; for(int j = i;j != 0; j &gt;&gt;= 1) num += j &amp; 1; ll lcm = 1; for (int j = 0; j &lt; m; j++)&#123; if (i &gt;&gt; j &amp; 1)&#123; lcm = lcm /gcd(lcm,a[j]) * a[j]; if (lcm &gt; n) break; &#125; &#125; if (num % 2 == 0) res -= n /lcm; else res += n / lcm; cout &lt;&lt; res &lt;&lt;endl; &#125; cout &lt;&lt; res &lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 巴什博奕（Bash Game）]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%A5%95%EF%BC%88Bash%20Game%EF%BC%89%2F</url>
    <content type="text"><![CDATA[描述：有一堆石子共有N个。A，B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。 例如：N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。 题解：显然，如果N=K+1，那么由于一次最多只能取K个，所以，无论A拿走多少个，B都能够一次拿走剩余的物品，B取胜。因此我们发现了如何取胜的法则：如果，（X为任意自然数，Y≤K)，那么A要拿走Y个物品，如果B拿走T（T≤K)个，那么A再拿走个，结果剩下个，以后保持这样的取法，那么A肯定获胜。总之，要保持给对手留下的倍数，就能最后获胜。 扩展：这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。 代码：1234567891011121314include&lt;stdio.h&gt;int main()&#123; long long N,K; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld%lld",&amp;N,&amp;K); if(N % (K + 1)) printf("A\n"); else printf("B\n"); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>巴什博奕（Bash Game）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[定义：康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 公式：$$X=an(n-1)!+a{n-1}(n-2)!+\ldots+a_1\cdot0! + 1$$ 其中，$a_i$为整数，并且$0\le a_i \le i,1\le i \le n.$ 用途：n位（0~n-1）全排列后，其康托展开唯一且最大约为n!，因此可以由更小的空间来储存这些排列。由公式可将X逆推出唯一的一个排列。 举例：对于一个有n个不同元素的集合${1,2,3,4,\dots,n}$的从小到大排序（从大到小 同理）的全排列 显然它有$n！$项。如n=4，那么就有$4！=4×3×2×1=24$项。 与自然数$1，2，3，4，\dots n！$与之一一对应。比如 $1～4$四个数的全排列按字典序如下： 1234：第一个 2134：第七个 3124：第13个 4123：第19个 1243：第二个 2143：第八个 3142：第14个 4132：第20个 1324：第三个 2314：第九个 3214：第15个 4213：第21个 1342：第四个 2341：第十个 3241：第16个 4231：第22个 1423：第五个 2413：第11个 3412：第17个 4312：第23个 1432：第六个 2431：第12个 3421：第18个 4321：第24个 问：求4132是第几个排列？ 解：总共4个数，所以n=4.ans:=0; 第一个数是4，研究比4小的并且还没有出现过的数有3个：1，2，3。 其中，a4 = 3 ，那么ans:=ans+3*(n-1)!所以 ans:= ans+ 3*(4-1)! =18 第二个数是1，研究比1小的并且还没有出现过的数为 0个。 其中，a3 = 0 ，那么ans:=ans+0 * (n-2)!，那么ans不变。 第三个数是3，研究比3小的并且还没有出现过的数为1个：1，2。 其中，a2 = 2 ，那么ans:=ans+ 1 (n-3)!,那么ans:=18+1 (4-3)!=19 第四个数是2，研究比2小的并且还没有出现过的数为0个。 其中，a1 = 0 ，那么ans不变。 最后ans怎么等于19啊？？代表它前面有19个排列嘛，那么4132自己就是第20个罗（ 最后ans:=ans+1） 逆展开：例：1～5从小到大全排列中，找出第96个排列？ 首先用96-1得到95，说明X之前有95个排列.(将此数本身减去！) 用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4. 用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5. 用5去除2!得到2余1，类似地，这一位是3. 用1去除1!得到1余0，这一位是2. 最后一位只能是1. 所以这个数是45321. 总结 + 代码：123456789101112131415161718192021222324252627282930int fac[] = &#123;1,1,2,6,24,120,720,5040,40320&#125;; //阶乘//康托展开int kt(int n,int s[])&#123; int sum = 0,smallNum; for(int i=0; i &lt; n; i++)&#123; smallNum = 0; //比当前数小的数 for(int j=i+1; j&lt;n; j++) if(s[i] &gt; s[j]) smallNum++; sum += smallNum * fac[n-i-1]; &#125; return sum;&#125;//康托逆展开void invKT(int n, int k, int s[])&#123; int t,j; bool visit[10] = &#123;false&#125;; //需要记录该数是否已在前面出现过 for(int i=0; i&lt;n; i++)&#123; t = k/fac[n-i-1]; for(j=1; j&lt;=n; j++)&#123; if(!visit[j])&#123; if(t == 0) break; t--; &#125; &#125; s[i] = j; visit[j] = true; k %= fac[n-i-1]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽屉原理]]></title>
    <url>%2F2016%2F12%2F28%2F%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[抽屉原理简述：第一抽屉原理： 把多于n+k个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。 把多于mn(m乘以n)+1（n不为0）个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。 把无穷多件物体放入n个抽屉，则至少有一个抽屉里 有无穷个物体。 第二抽屉原理： 把$（mn－1）$个物体放入n个抽屉中，其中必有一个抽屉中至多有$（m—1）$个物体 (例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)。 HDU_1205 吃糖果Problem DescriptionHOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？请你写个程序帮忙计算一下。 Input第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0&lt;N&lt;=1000000)，第二行是N个数，表示N种糖果的数目Mi(0&lt;Mi&lt;=1000000)。 Output对于每组数据，输出一行，包含一个”Yes”或者”No”。 Sample Input234 1 155 4 3 2 1 Sample OutputNoYes 题解：设其中某类糖果的数量最多，数量为max，总的糖果数为sum，如果mam&gt;sum-max+1；则一定不能吃完，否则能吃完。 代码：1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; __int64 n,m,t,max,sum; scanf("%I64d",&amp;t); while(t--)&#123; sum=0; max=0; scanf("%I64d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%I64d",&amp;m); sum+=m; if(max&lt;m) max=m; &#125; sum-=max; if(max&gt;sum+1) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; HDU_1808 Halloween treatsProblem DescriptionEvery year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided. Your job is to help the children and present a solution. InputThe input contains several test cases.The first line of each test case contains two integers c and n (1 ≤ c ≤ n ≤ 100000), the number of children and the number of neighbours, respectively. The next line contains n space separated integers a1 , … , an (1 ≤ ai ≤ 100000 ), where ai represents the number of sweets the children get if they visit neighbour i. The last test case is followed by two zeros. OutputFor each test case output one line with the indices of the neighbours the children should select (here, index i corresponds to neighbour i who gives a total number of ai sweets). If there is no solution where each child gets at least one sweet, print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them. Sample Input4 51 2 3 7 53 67 11 2 5 13 170 0 Sample Output3 52 3 4 题解：有c个孩子，去n个邻居家要糖果，现在已知每个邻居所能给的糖果数ai，问怎么个要法能保证全部所得的糖果能被c个孩子平分。 我们考虑前k个邻居的糖果总数，那么这样的和一共有n个，a1，a1+a2，…，a1+…+an，如果将他们分别除以孩子的个数c，那么余数只可能在1~c-1之间，换句话说，和有n个，而余数有c-1个，并且从题目中可知c&lt;=n，那么根据抽屉原理可知，必然有两个和的余数是相同的，这也就意味着这两个和中包含的公有项的和能被c整除，即为所求答案。 代码：12345678910111213141516171819202122232425262728293031323334include &lt;cstdio&gt;include &lt;cstring&gt;const int MAXN = 1e5+5;int a[MAXN], SumMod[MAXN], flag[MAXN];int main()&#123; int c, n; while(~scanf("%d%d", &amp;c, &amp;n) &amp;&amp; (c+n)) &#123; SumMod[0] = 0; memset(flag, 0, sizeof(flag)); for(int i=1; i&lt;=n; ++i) scanf("%d", &amp;a[i]); for(int i=1; i&lt;=n; ++i) &#123; SumMod[i] = (SumMod[i-1] + a[i]) % c; // 处理前缀和，并取模 if(flag[SumMod[i]] == 0) flag[SumMod[i]] = i; else // 如果相同的余数在前面出现过 &#123; int j = flag[SumMod[i]] + 1; int k = j; for(; j&lt;=i; ++j) // 公共项即为答案 if(j == k) printf("%d", j); else printf(" %d", j); break; &#125; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>抽屉原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裴蜀等式]]></title>
    <url>%2F2016%2F12%2F28%2F%E8%A3%B4%E8%9C%80%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在数论中，裴蜀等式（Bézout’s identity） 或 裴蜀定理 是一个关于最大公因数的定理： 对于正整数 a, b，存在s,t∈Z 使 sa + t b = gcd (a,b) 成立。 根据互质的定义证明以下命题:​ 正整数a,b∈$Z^+$互质当且仅当存在整数s,t∈$Z $满足 sa+tb=1。 证明：​ 1. 已知整数 $a$ 和 $b$ 互质，那么$gcd{(a,b)}=1$，所以存在整数$s,t$ 使得 $1 = sa+tb$；​ 2. 假设存在一个整数 dd 是正整数 aa 和正整数 bb 的公共因子，则$ d\mid a$且 $d\mid b$；​ 3. 因为 $d$ 是 $a $的因数，且 $s$ 是整数，所以 $d$ 也一定是 $sa$ 的因数，也就是说 $d\mid sa,d∣sa$；​ 4. 因为 $d$ 是 $b$ 的因数,且 $t$ 是整数,所以 $d$ 也一定是 $tb$ 的因数，也就是说 $d\mid tb,d∣tb$；​ 5. 存在整数 $m,n$ 使得我们可以将 $sa$ 表示为 $md$，将 $tb$ 表示为 $nd$；所以，我们可以得 $sa+tb = md+nd = (m+n)d$；由此我们可以知道 $d\mid (sa+tb)$；​ 6. 因为我们已知 $sa+tb = 1$,所以 $d \mid 1$。由此，我们只能是 $d = 1$ 或 $d = -1$。所以 $a$ 和 $b$的公共正整数因子只有 1，所以 $a,b\in \mathbb{Z^+}$ 互质；​ 7. 综上可得“正整数 $a,b\in \mathbb{Z^+}$。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>裴蜀等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的开始——如何搭建Hexo]]></title>
    <url>%2F2016%2F12%2F27%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BC%80%E5%A7%8B%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAHexo%2F</url>
    <content type="text"><![CDATA[概述导语 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且能一键部署到GitHub Pages。 首先，不论这篇文章主要是为了安装什么，第一步该做的是先说明一遍大致的过程，以使读者能够清楚，自己究竟在干什么、还有什么没有完成、为什么要这么做。当然，我会给出一些必要的网站，它们以官网为主，庆幸的是，这些官网都有简体中文的支持。最后，说明一下作者的系统为Mint Linux，它和Ubuntu是一样的，并且作者是一个大二菜鸟，如果有错的话，希望大家能够指出错误，我也会立即改正。 具体过程 准备安装环境 Node.js Git 安装Hexo 开始搭建博客 初始化Hexo 修改全局配置文件 一次简单的同步 添加新文章 更换主题 给出网址 Hexo官方网站 Material主题官网 史上最详细的Hexo博客搭建图文教程 准备安装环境安装Node.js很不幸运的是官方给出的 Node.js 安装方法并不是非常有效。因此我通过Baidu找到了一种简单的方法，在此给出过程。 下载 第一步很简单，就是从官网上下载二进制包。给出地址。 Node.js官网下载地址 解压下载好的 node-v6.9.2-linux-x64.tar.xz 压缩包 1$ tar xvf node-v6.9.2-linux-x64.tar.xz 这样，你可以得到一个名为 node-v6.9.2-linux-x64 的文件夹。 验证 Node.js 的版本 首先进入 node-v6.9.2-linux-x64 文件夹下的 bin 目录，你会发现有两个可执行文件。如下： 123$ cd node-v6.9.2-linux-x64/bin$ lsnode npm 接着我们来看看 Node.js 的版本 12$ ./node -vv6.9.2 很好，它是最新的6.9.2版本。 把二进制包放到较为规范的地方。 什么叫较为规范的地方？举个例子，在Windows下，排除自己定义安装路径的软件，你所有的软件都会在这样一个地址下 C:\Program Files 。在Mint Linux上，我把它规定为 /opt ，这个路径包含了所有我手动安装的软件，毕竟虽然有 apt ，但是总有些软件不能通过apt安装。很好，下面让我们把它挪到那个规范的地方。 1234$ sudo mv node-v6.9.2-linux-x64 /opt/$ cd /opt$ lsclion eclipse google node-v6.9.2-linux-x64 pycharm sublime_text 由此你可以发现，我已经成功移动了文件。这里有个小问题，在执行第一句命令的时候，会提示需要密码，不要担心，直接输入root密码就行，它不是明文的，并不会显示字符。 建立软链接，设置全局 怎么在shell中直接访问呢？就是通过软链接实现。 123456$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/node /usr/local/bin/node$ sudo ln -s /opt/node-v6.9.2-linux-x64/bin/npm /usr/local/bin/npm$ cd /usr/local/bin/$ ls |grep &apos;^[n]&apos;nodenpm 你会发现，在 /usr/local/bin这个目录下已经有 node 、npm 两个文件了。 验证成功 打开terminal，输入node -v和npm -v 来检查是否成功。 1234$ node -vv6.9.2$ npm -v3.10.9 由此Node.js安装完成，看似很复杂，其实很简单。 安装GitGit的安装是通过apt，极其便捷。 1sudo apt-get install git 这样就安装完了。这就是包管理的好处。 其次，ssh的配置安装则参考Git教程 - 廖雪峰的官方网站 ,这是非常好的git教程网站。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。根据官方教程： 1$ npm install -g hexo-cli 如果出现WARNING，那么你可以忽视它。如果出现ERROR，那么请你使用Baidu或者Bing来解决问题，作者病不能，开速有效的替你解决。 开始搭建博客初始化Hexo首先，我打算把博客的根地址定在 ～/Document/ 。那么开始 1234$ cd ~/Documents/$ hexo init Blog$ cd Blog$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注意，这里有一些问题。执行第二个命令时常常由于网络的问题卡住，那么建议你把npm的源改为淘宝源，具体教程查看npm设置淘宝镜像 修改全局配置文件您可以在 _config.yml 中修改大部份的配置。当然参考官方文档以获得最好的支持 当然你可以查看我的修改方法。 网站 参数 描述 我的配置 title 网站标题 Francis’Blog subtitle 网站副标题 description 网站描述 author 作者的名字 Andy Francis language 网站使用的语言 zh-CN timezone 网站时区 Asia/Shanghai 网址 参数 描述 我的配置 url 网址 https://dongfrancis.github.io/ root 网站根目录 / permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_default 永久链接中各部分的默认值 目录 参数 描述 我的配置 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章 参数 描述 我的配置 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 分类 &amp; 标签 参数 描述 我的配置 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 我的配置 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 我的配置 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 我的配置 theme 当前主题名称。值为false时禁用主题 material 此theme的配置默认为landscape，我这里的material为其它主题。 Deployment deploy:​ type: git​ repo: git@github.com:DongFrancis/DongFrancis.github.io.git​ branch: master 一次简单的同步本地尝试如果以上内容你已经完成那么我们可以试着在本地测试一下，首先你必须进入博客的根目录，其次启动服务。想这样： 123$ cd ~/Documents/Blog$ hexo generate$ hexo server 然后打开浏览器，进入地址 http://localhost:4000/ ，你会发现你的个人博客已经搭建完成！！！ 同步到Github Pages 如果你想同步到Github Pages，确保你已经完成了 git的安装与配置、 git的ssh设置、 Github Pages的申请与建立、Deployment的配置 。 很好，现在我们可以继续了。 安装插件进入Blog根目录，执行如下操作 1$ npm install hexo-deployer-git --save 同步——deploy在Blog根目录，执行如下操作 1$ hexo deploy 验证打开Github pages的个人主页，如 https://DongFrancis.github.io.git，你可以验证是否同步成功。 四、添加新文章创建一篇新文章在Blog根目录下，你可以使用 new命令来新建文章。如 1$ hexo new &quot;my-first-blog&quot; 执行完此命令后，在source/_posts/ 目录下会有一个新的文件 my-first-blog.md 。 测试毫无疑问，对于自己些的文章，你总希望确认一下是否完美，这样你才可以展示给其它人看。 具体这样来完成： 12$ hexo generate$ hexo server 很熟悉的俩句话是么？没错，这就是本地测试的俩个命令，第一句的意思是生成文件，第二局的意思是打开本地服务器 。 同步到Github Pages很简单使用 deploy 命令即可。 1$ hexo deploy 执行完命令后，你便可以在Github Pages上查看了。 更换主题我选择的是 Meterial 主题，一句话：好看！ 具体的过程和官网的教程一样这里就不详细讲了。 总结搭建博客的作用对于不同的人有不同的作用。对于我来说，是希望将自己所学的知识进一步整理与归纳，以此逐步提升自己。希望这篇教程对大家有所帮助。]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>